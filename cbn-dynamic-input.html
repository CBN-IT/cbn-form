<!--
`cbn-dynamic-input` is a proxy Polymer element that automatically renders a dynamic input (using its config object).

Each input element must implement CbnAbstractInputMixin and have several required properties specified 
(see 'cbn-form-abstract.html').

Several special config attributes are supported: 
- 'element': set to override automatic element detection by using the 'type' attribute;
- 'className': HTML classes to apply to the decorator/input, if the decorator is null (can be an Array of Strings or a String); 
- 'style': the style to apply to the root decorator/input (can be a CSS String or an object with CSS properties to set);
- 'decorator': the name of the HTML element to use as decorator (set to null to skip decorating).

@group cbn-form
@element cbn-dynamic-input
-->

<!-- Imports -->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="cbn-form-abstract.html">

<polymer-element name="cbn-dynamic-input" attributes="config preview">
	
	<template>
		<!-- No local DOM necessary; the element appends the generated content as sibling -->
	</template>
	
	<script>
		Polymer('cbn-dynamic-input', {
			
			/**
			 * The input field's configuration object.
			 * 
			 * @typedef  {Object}	FormFieldConfig
			 * @property {String} 	type 	The element's type (used to instantiate the element based on type).
			 * @property {String} 	element	The name of the element to instantiate (forced, overrides the type). Optional.
			 * @property {String}	name	The input name / model value's path (that describes where in the model the 
			 * 								data should be read / written).
			 * @property {String}	preview	Whether the element is visible in a preview-state form group.
			 * 
			 * All other properties are directly passed as attributes to the instantiated element only if they were 
			 * specified inside the {@link CbnAbstractInputMixin#inputAttributes} array.
			 */
			
			/**
			 * The form input configuration object. Should contain at least the 'type' (or 'element') and 'name' 
			 * properties.
			 * 
			 * @attribute config
			 * @type FormFieldConfig
			 * @default {}
			 */
			config: null,
			
			/**
			 * The HTML element of the created input.
			 * 
			 * @type {HTMLElement}
			 * @default null
			 */
			element: null,
			
			/**
			 * The HTML element of the created decorator.
			 * 
			 * @type {HTMLElement}
			 * @default null
			 */
			decorator: null,
			
			/**
			 * Fires when the element is created. Used to initialize its attributes.
			 */
			created: function () {
				if (!this.config) 
					this.config = {};
			},
			
			/**
			 * Called when polymer element has been fully prepared.
			 * 
			 * Creates the actual input element based on the given `type` or `element` parameter.
			 */
			ready: function () {
				var elementName;
				if (this.config.element) {
					elementName = this.config.element;
				} else {
					elementName = CbnFormInputs._registeredTypes[this.config.type];
					if (!elementName) {
						console.error("Polymer(\"cbn-dynamic-input\"): input type not registered ('" +
						this.config.type + "')");
						return false;
					}
				}
				this.element = document.createElement(elementName);
				if (!this.element || !this.element.isFormInput || !this.element.inputAttributes) {
					console.error("Polymer(\"cbn-dynamic-input\"): invalid input element ('" +
					elementName + "')");
					return false;
				}
				
				// create the decorator element
				var root = this.element;
				this.decorator = null;
				if (this.config.decorator) {
					this.decorator = document.createElement(this.config.decorator);
					if (!this.decorator || !this.decorator.decoratorAttributes) {
						console.error("Polymer(\"cbn-dynamic-input\"): invalid decorator element ('" +
						this.config.decorator + "')");
						return false;
					}
					root = this.decorator;
					
					// set the element's display to 'block'
					this.element.style.display = 'block';
					
					// set decorator default config attributes (from the element's 'decoratorConfig' property)
					if (this.element.decoratorConfig) {
						for (var dc in this.element.decoratorConfig) {
							if (!this.element.decoratorConfig.hasOwnProperty(dc)) 
								continue;
							
							this.applyConfig(this.decorator, dc, this.element.decoratorConfig[dc]);
						}
					}
				}
				
				// set element attributes
				for (var c in this.config) {
					if (!this.config.hasOwnProperty(c)) 
						continue;
					
					if (c == 'style' || c == 'className') {
						// always apply to the root element
						this.applyConfig(root, c, this.config[c]);
						
					} else {
						if (this.decorator && this.decorator.decoratorAttributes.indexOf(c) >= 0) {
							this.applyConfig(this.decorator, c, this.config[c]);
						}
						if (this.element.inputAttributes.indexOf(c) >= 0) {
							this.applyConfig(this.element, c, this.config[c]);
						}
					}
				}
				
				if (this.decorator) {
					root.appendChild(this.element);
				}
				
				// append the element as sibling
				if (this.nextSibling) {
					this.parentnode.insertBefore(root, this.nextSibling);
					
				} else {
					this.parentNode.appendChild(root);
				}
			},
			
			/**
			 * Applies the specified configuration parameter to the element.
			 * 
			 * @param element The element to set the config attribute for.
			 * @param c The config attribute.
			 * @param value The config value to set.
			 */
			applyConfig: function(element, c, value) {
				if (c == 'style') {
					if (typeof value == 'object') {
						for (var s in value) {
							if (value.hasOwnProperty(s))
								element.style[s] = value[s];
						}
						
					} else {
						element.style.cssText = value;
					}
					
				} else if (c == 'className') {
					if (typeof value == 'object' && value.length) {
						element.className = value.join(' ');
					} else {
						element.className = value.toString();
					}
					
				} else if (c == "preview") {
					if (value)
						element.setAttribute(c, value);
					else 
						element.removeAttribute(c);
					
				} else {
					element[c] = value;
				}
			}
			
		});
	</script>
	
</polymer-element>
