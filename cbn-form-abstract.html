<!--
This file defines the common utilities and interfaces necessary by some components.

Each input element must implement abstract interfaces, have a declared `is-form-input` HTML 
attribute and .

This file defines the interfaces for several form controls: 
- `AbstractControl`: the common interface that all form controls must implement;
- `AbstractInput`: the interface that form input fields must implement;
- `AbstractFileInput`: a special interface to use for file inputs;
- `AbstractContainer`: a special form control that can contain other controls/fields;

A custom form element must implement one of these interfaces, depending on its desired form behavior.
Also, the element must register its type[s] via the {@link CbnFormInputs#registerElement} (used for dynamic form input 
type discovery).
-->

<script>
	
	// JSDoc types
	
	/**
	 * The dynamic form template object.
	 * 
	 * @typedef  {Object} 				FormConfig
	 * @property {Object}				[types] Used to override the default type-to-element mapping.
	 * @property {Object}				[defaults] Default configuration object, applied to all objects that have an 
	 *                                  inherit property. There also is a special wildcard ('*') key that applies the 
	 *                                  defaults to every `FormElementConfig` template.
	 * @property {FormElementConfig[]} 	controls The form controls to render.
	 */
	
	/**
	 * The dynamic template object for a single form control.
	 * 
	 * @typedef  {Object}	FormElementConfig
	 * 
	 * @property {String} 	[inherit] The default config key to inherit (see {@link FormConfig#defaults}). Optional.
	 * @property {String} 	[type]    The element's type (used to instantiate an element based on type).
	 * @property {String} 	[element] The name of the element to instantiate (optional, overrides the type).
	 * 
	 * // input-specific properties
	 * @property {String} 	[decorator] The name of the decorator element that wraps the element (optional).
	 * @property {String}	[name]	  The input name / model value path (that describes where in the model the 
	 * 								  data should be read from / written to).
	 * @property {String}	[preview] Whether the element is visible in a preview-state form group.
	 * 
	 * // container-specific properties: 
	 * @property {FormElementConfig[]}  [children] The list of container children to render (recursively).
	 * @property {Object|{ element: String }} [wrapChildren] A plain object that contains the template to use for 
	 *                                rendering a standard HTML element that wraps the children. Optional.
	 * 
	 * All other properties are directly passed as attributes to the instantiated element only if they were specified 
	 * inside the {@link CbnForm.AbstractControl#inputAttributes} array.
	 */
	
	
	/**
	 * Class that exposes a public API used for implementing form controls.
	 */
	var CbnForm;
	
	CbnForm = {
		
		/**
		 * Stores the registered inputs by type.
		 * The key is the input/control type and the value is the element's name.
		 * 
		 * @private
		 * @type { Object.<String, String> }
		 */
		_registeredTypes: {},
		
		/**
		 * Stores the registered elements as a Boolean map.
		 * 
		 * @private
		 * @type { Object.<String, Object> }
		 */
		_registeredElements: {},
		
		
		// Element registration methods:
		
		/**
		 * @typedef  {Object}   RegisterElementOptions
		 * @property {String[]} [types] The input types handled by the element.
		 * @property {String}   [extends] If the element extends another one, set this to the extended element 
		 *                      (e.g.: 'input')
		 */
		
		/**
		 * Registers a new form control element to be usable within `cbn-form` and `cbn-dynamic-form`.
		 * 
		 * @param {String} name The name of the custom input element.
		 * @param {RegisterElementOptions} options Element's definition object.
		 */
		registerElement: function (name, options) {
			if (this._registeredElements[name] != undefined) {
				console.error("\"cbn-form-abstract.html\": element '" + name + "' is already registered");
				return false;
			}
			
			if (options.types && options.types.length) {
				for (var i=0; i<options.types.length; i++) {
					this._registeredTypes[options.types[i]] = name;
				}
			}
			
			this._registeredElements[name] = options;
			
			return true;
		}, 
		
		/**
		 * Returns a registered element's definition object.
		 * 
		 * @param  {String} name The element's name.
		 * @return {RegisterElementOptions} Element's registration options.
		 */
		getRegisteredElement: function(name) {
			return this._registeredElements[name];
		}, 
		
		/**
		 * Returns the name of an element that was last registered for the requested type.
		 * 
		 * @param  {String} type The input type.
		 * @param  {Object} [overrideTypes=null] Optional, types override map.
		 * @return {String} The element's name.
		 */
		getElementForType: function(type, overrideTypes) {
			if (overrideTypes && overrideTypes.hasOwnProperty(type))
				return overrideTypes[type];
			return this._registeredTypes[type];
		},
		
		/**
		 * Method used for implementing control abstract interfaces (like AbstractInput, AbstractContainer etc.) for a 
		 * polymer object.
		 * 
		 * A Polymer.mixin implementation that extends published properties, event handlers etc.
		 * Inspired from https://github.com/Polymer/polymer/issues/846.
		 * 
		 * @param {Object} obj The target object to extend.
		 */
		implement: function (obj/*, mixin1 ...*/) {
			var i, p, n, m, match; // iterators / auxiliary variables
			
			var overrideMethod = function(method) {
				var f = function() {
					var i;
					if (!this['_overriddenMethods'] || !this['_overriddenMethods'][method])
						return;
					
					if (this['_overriddenMethods'][method].before) 
						for (i=0; i<this['_overriddenMethods'][method].before.length; i++ ) {
							this['_overriddenMethods'][method].before[i].apply(this, arguments);
						}
					if (this['_overriddenMethods'][method].orig) {
						this['_overriddenMethods'][method].orig.apply(this, arguments);
					}
					if (this['_overriddenMethods'][method].after) 
						for (i=0; i<obj['_overriddenMethods'][method].after.length; i++ ) {
							this['_overriddenMethods'][method].after[i].apply(this, arguments);
						}
				};
				f._overriddenMethodDecorator = true;
				return f;
			};
			
			var initOverride = function(obj, method) {
				if (!obj._overriddenMethods[method]) 
					obj._overriddenMethods[method] = {
						before: [],
						orig: null,
						after: []
					};
			};
			
			// copies a property from a source object to a target object
			function copyProperty(name, source, target) {
				if (target.hasOwnProperty(name)) return; // skip if the property already exists
				var pd = getPropertyDescriptor(source, name);
				Object.defineProperty(target, name, pd);
			}
			// returns the property descriptor of an object; searches the object's prototype chain
			function getPropertyDescriptor(obj, name) {
				if (obj) {
					var pd = Object.getOwnPropertyDescriptor(obj, name);
					return pd || getPropertyDescriptor(Object.getPrototypeOf(obj), name);
				}
			}
			
			// internally used properties
			obj = obj || {};
			
			/**
			 * Stores the references of all mixins implemented so far.
			 * @private
			 * @property _implementedMixins
			 * @type {Object[]}
			 */
			if (!obj._implementedMixins) obj._implementedMixins = [];
			
			/**
			 * A map with the overridden methods.
			 * The key is the method name.
			 * 
			 * @private
			 * @property _overriddenMethods
			 * @type {Object<String,{before:Function[], , after:Function[]}>}
			 */
			if (!obj._overriddenMethods) obj._overriddenMethods = {};
			
			var lifecycleMethods = ["created", "ready", "attached", "domReady", "detached", "attributeChanged"];
			var doNotCopyProps = ["_extendProperties", "_implementedMixins", "_overriddenMethods"];
			var alwaysExtendProps = ["publish"];
			
			var methodsMap = {};
			lifecycleMethods.forEach(function (key) {
				methodsMap[key + '_'] = key;
				methodsMap['_' + key] = key;
			});
			for (i = 1; i < arguments.length; i++) {
				p = arguments[i];
				for (n in p) {
					if (!p.hasOwnProperty(n)) continue;
					if ( (match = /^([a-zA-Z0-9_]+Changed)_$/.exec(n)) || (match = /^_([a-zA-Z0-9_]+Changed)$/.exec(n)) ) {
						methodsMap[n] = match[1];
					}
				}
			}
			
			for (i = 1; i < arguments.length; i++) {
				p = arguments[i];
				
				// inherit the overridden methods
				if (p._overriddenMethods) {
					for (m in p._overriddenMethods) {
						if (!p._overriddenMethods.hasOwnProperty(m)) continue;
						initOverride(obj, m);
						if (p._overriddenMethods[m].before) 
							obj._overriddenMethods[m].before = obj._overriddenMethods[m].before.concat(p._overriddenMethods[m].before);
						if (p._overriddenMethods[m].after)
							obj._overriddenMethods[m].after = obj._overriddenMethods[m].after.concat(p._overriddenMethods[m].after);
						if (p._overriddenMethods[m].orig && !obj._overriddenMethods[m].orig)
							obj._overriddenMethods[m].orig = p._overriddenMethods[m].orig;
					}
				}
				// copy properties from mixin
				for (n in p) {
					if (!p.hasOwnProperty(n)) continue;
					
					if (methodsMap.hasOwnProperty(n)) {
						// special case: lifecycle/observer methods
						var method = methodsMap[n];
						initOverride(obj, method);
						
						if (n.indexOf('_') == 0) {
							obj._overriddenMethods[method].before.push(p[n]);
						} else {
							obj._overriddenMethods[method].after.push(p[n]);
						}
						
					} else if (doNotCopyProps.indexOf(n) != -1) {
						// special mixin property, do not copy
						
					} else {
						// custom property
						if ( (alwaysExtendProps.indexOf(n) != -1) ||
								(p.hasOwnProperty('_extendProperties') && p['_extendProperties'].indexOf(n) != -1)) {
							
							// extend the property (if it is an array or an object)
							if (p[n] instanceof Array) {
								if (!obj[n]) obj[n] = [];
								obj[n] = p[n].concat(obj[n]);
							} else if (typeof p[n] == 'object') {
								if (!obj[n]) obj[n] = {};
								for (var nk in p[n]) {
									if (!p[n].hasOwnProperty(nk)) continue;
									copyProperty(nk, p[n], obj[n]);
								}
							}
							
						} else {
							// just copy it (if it doesn't override)
							try {
								copyProperty(n, p, obj);
							} catch (e) {
								console.error("CbnForm.define: unable to copy object property '" + n + "'!",
									obj, e);
							}
						}
					}
					
					// nice to have: also extend eventDelegates handlers, property observers etc.
				}
				
				// insert the current interface to the implemented mixins list
				if (obj._implementedMixins.indexOf(p) == -1)
					obj._implementedMixins.push(p);
				if (p._implementedMixins) {
					for (var j=0; j < p._implementedMixins.length; j++) {
						if (obj._implementedMixins.indexOf(p._implementedMixins[j]) == -1)
							obj._implementedMixins.push(p._implementedMixins[j]);
					}
				}
				
				for (m in obj._overriddenMethods) {
					if (!obj._overriddenMethods.hasOwnProperty(m)) continue;
					if (!obj[m] || !obj[m]._overriddenMethodDecorator) {
						if (obj[m]) {
							// save the original method
							obj._overriddenMethods[m].orig = obj[m];
						}
						obj[m] = overrideMethod(m);
					}
				}
			}
			return obj;
		}, 
		
		/**
		 * Checks whether an object implements the specified mixin.
		 * Only usable with {@link #implement}.
		 * 
		 * @param  {Object}  obj The object to check.
		 * @param  {Object}  mixin The mixin to check if it is implemented by the object.
		 * @return {Boolean} True if the object implements the mixin. 
		 */
		implements: function (obj, mixin) {
			if (!obj._implementedMixins || !obj._implementedMixins.length) 
				return false;
			return (obj._implementedMixins.indexOf(mixin) != -1);
		}
		
	};
	
	/**
	 * An empty object with "null" meaning.
	 * 
	 * Used as hack to be able to have null-able object properties and still let Polymer know the type of the expected 
	 * value. See {@link CbnForm.AbstractContainer#model} for an example.
	 */
	CbnForm.NullObject = {};
	
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Defines the abstract interface to be implemented by the custom form controls.
	 * 
	 * Note: you need to use the {@link CbnForm#mixin} method to implement this abstract interface (or any of the 
	 * derived interfaces below) to a custom element!
	 * 
	 * Example:
	 *     Polymer('your-element', CbnForm.mixin({
	 *         // element's properties
	 *     }, CbnForm.AbstractInput));
	 *     
	 * @extends HTMLElement
	 */
	CbnForm.AbstractControl = {
		
		/**
		 * Publish additional element properties.
		 */
		publish: {
			isFormControl: {
				value: true, 
				reflect: true // set as attribute
			}
		}, 
		
		/**
		 * Stores reference to the element's parent `cbn-form` element.
		 * Available just after the element's `attached` event is processed (the element's `attached` callback is fine).
		 * @type {HTMLElement}
		 */
		parentForm: null, 
		
		// Fired events:
		
		/**
		 * Fired automatically when a form control attaches. Bubbles up the DOM tree.
		 * @event cbn-form-control-attached
		 */
		
		/**
		 * Fired automatically when a form control is detached from DOM. Bubbles up the DOM tree.
		 * @event cbn-form-control-detached
		 */
		
		/**
		 * Sends an event to notify the parent containers of the element's attachment.
		 */
		_attached: function () {
			var element = this;
			this.fire('cbn-form-control-attached', {
				element: element
			}, null, true, false);
		},
		
		/**
		 * Sends an event to notify the parent containers of the element's detachment.
		 */
		_detached: function () {
			var element = this;
			this.fire('cbn-form-control-detached', {
				element: element
			}, null, true, false);
		}
		
	};
	
	//noinspection JSUnusedGlobalSymbols
	/**
	 * Defines the abstract interface of form controls that support dynamic element creation.
	 * 
	 * Each element must specify the list of accepted template properties using the {@link #dynamicAttributes} object.
	 */
	CbnForm.DynamicControl = {
		
		// Interface settings
		_extendProperties: [ 'dynamicAttributes' ], 
		
		/**
		 * Defines form element's dynamically-configurable attributes. 
		 * Should not be changed after the Polymer `create` event is finished!
		 * 
		 * @type {Object<String,Object> | Object<String,String> | Object<String,Boolean>}
		 * @default { style, className }
		 */
		dynamicAttributes: {
			"style"     : { type: "style" }, 
			"className" : { type: "className" }
		}, 
		
		/**
		 * Stores the source object used to generate the current instance. 
		 * Filled by `cbn-dynamic-form` at element creation time.
		 * @type {FormElementConfig}
		 */
		sourceTemplate: null, 
		
		/**
		 * Polymer element created callback.
		 * 
		 * Normalizes the {@link #dynamicAttributes} property.
		 */
		created_: function() {
			for (var i in this.dynamicAttributes) {
				if (!this.dynamicAttributes.hasOwnProperty(i)) continue;
				
				if (this.dynamicAttributes[i] === true) 
					this.dynamicAttributes[i] = {};
				if (!this.dynamicAttributes[i].name) 
					this.dynamicAttributes[i].name = i;
				if (!this.dynamicAttributes[i].type) 
					this.dynamicAttributes[i].type = 'attribute';
			}
		}, 
		
		/**
		 * Returns the attribute descriptor of a dynamic attribute, if any.
		 * 
		 * @param {String}  name The name of the attribute.
		 * @param {Boolean} [inferDefault=false] If no descriptor exists, infer its defaults. 
		 */
		getDynamicAttributeDescriptor: function(name, inferDefault) {
			var attribute = this.dynamicAttributes[name];
			if (!attribute && inferDefault) 
				attribute = { type: 'attribute', name: name };
			
			return attribute;
		},
		
		/**
		 * Sets a dynamic attribute to the specified value.
		 * 
		 * If the attribute descriptor isn't defined, it is assumed to be `{ type: 'attribute', name: name }`.
		 * 
		 * @extends HTMLElement
		 * @param {String} name The name of the dynamic attribute to set.
		 * @param {*}      value The attribute value to set.
		 */
		setDynamicAttribute: function(name, value) {
			var attribute = this.getDynamicAttributeDescriptor(name, true);
			
			if (attribute.type == 'style') {
				if (typeof value == 'object') {
					for (var s in value) {
						if (value.hasOwnProperty(s))
							this.style[s] = value[s];
					}
					
				} else {
					this.style.cssText = value;
				}
				
			} else if (attribute.type == 'className') {
				if (typeof value == 'object' && value.length) {
					this.className = value.join(' ');
				} else {
					this.className = value.toString();
				}
				
			} else if (attribute.type == "attribute") {
				if (value === false) 
					this.removeAttribute(attribute.name);
				else
					this.setAttribute(attribute.name, value);
				
			} else if (attribute.type == 'property') {
				this[attribute.name] = value;
			}
		}
		
	};
	
	
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Defines the abstract interface to be implemented by the custom input elements.
	 * 
	 * @extends CbnForm.AbstractControl
	 */
	CbnForm.AbstractInput = CbnForm.implement({
		
		// Interface settings
		_extendProperties: [ 'dynamicAttributes' ],
		
		publish: { // Published attributes:
			
			/**
			 * Input's name. 
			 * 
			 * It is used as model binding path 
			 * For example, the value 'name.first_name' will bind to the model path `model.name.first_name`.
			 * 
			 * @attribute name
			 * @type {String}
			 */
			
			/**
			 * Input's value attribute.
			 * Should be String for most of the cases, Array if the input supports multiple values and Object for
			 * special input types (e.g. file). And array of objects for special types with multiple values, ofc. ;)
			 * 
			 * @attribute value
			 * @type { Array | Object | [String] | [Object]}
			 */
			
			/**
			 * Is the input currently in a preview state?
			 * 
			 * Automatically bound by the `cbn-form-group` component if the {@link #preview} property is true.
			 * 
			 * @attribute previewState
			 * @type {Boolean}
			 */
			previewState: false
			
		},
		
		// Events
		
		/**
		 * Custom inputs should fire `input` and `changed` events whenever the value is changed / committed.
		 * 
		 * The `input` event is fired every time the input's value changes (e.g. for every character typed).
		 * 
		 * The event bubbles. 
		 * If your input contains other inputs, it should stop their bubbling events (i.e. hide them).
		 * 
		 * @event input
		 */
		
		/**
		 * The `change` event should be fired when the input value is committed (e.g. the element loses focus).
		 * The event bubbles.
		 * 
		 * @event change
		 */
		
		// DOM Properties:
		
		/**
		 * Should be false if the element doesn't need to bind to the form's model. 
		 * @type {Boolean}
		 */
		hasModelValue: true, 
		
		/**
		 * Standard form input dynamically-configurable attributes.
		 */
		dynamicAttributes: {
			"type" 		: { type: 'attribute' }, 
			"name" 		: { type: 'attribute' }, 
			"preview"	: { type: 'attribute' }
		},
		
		/**
		 * Optional properties to pass to the parent decorator element (if any).
		 * 
		 * Use if you require special treatment from the decorator. Only used by the dynamic form.
		 * 
		 * @type {Object}
		 */
		decoratorConfig: null,
		
		/**
		 * Stores the parent container element bound to the input's model object.
		 * Available just after the element's `attached` event is processed (the element's `attached` callback is fine).
		 * @type {HTMLElement}
		 */
		modelContainer: null,
		
		// Callback methods
		
		/**
		 * Element instance created callback.
		 */
		_created: function () {
			if (!this.decoratorConfig)
				this.decoratorConfig = {};
		}
		
	}, CbnForm.AbstractControl);
	
	/**
	 * Defines the abstract interface to be implemented by the custom file input elements.
	 * 
	 * @extends CbnForm.AbstractInput
	 */
	CbnForm.AbstractFileInput = CbnForm.implement({ 
		
		/**
		 * This method should be implemented by file inputs.
		 * Used by the primary form component to send the uploaded files via AJAX.
		 * 
		 * @return {FileList} A FileList (preferably) object that contains the selected files.
		 */
		getFiles: function () {
			throw "Not implemented!";
		}
		
	}, CbnForm.AbstractInput);
	
	
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Defines the abstract interface to be implemented by the custom input decorators.
	 * 
	 * An input decorator is an element that wraps the actual input inside (via light DOM) and can show several other UI 
	 * elements around it (such as labels, validation errors etc.).
	 * 
	 * @extends CbnForm.AbstractControl
	 */
	CbnForm.AbstractInputDecorator = CbnForm.implement({
		
		publish: { // Published attributes:

			/**
			 * Whether the current instance should be shown as preview in form groups.
			 *
			 * @attribute preview
			 * @type {Boolean}
			 */
			preview: false,

			/**
			 * Is the input container currently in a preview state?
			 *
			 * Automatically bound by the `cbn-form-group` component if the {@link #preview} property is true.
			 *
			 * @attribute previewstate
			 * @type {Boolean}
			 */
			previewState: false
		},
		
		/**
		 * Standard input decorator dynamically-configurable attributes.
		 */
		dynamicAttributes: {
			"label"  : { type: 'attribute' }, 
			"preview": { type: 'attribute' }
		}, 
		
		
		// Element lifecycle methods:
		
		/**
		 * Element instance created callback.
		 */
		_created: function () {
			// nothing yet
		}, 
		
		/**
		 * Polymer element ready callback.
		 */
		_ready: function () {
			// nothing yet
		}
		
	}, CbnForm.AbstractControl);
	
	// noinspection JSUnusedGlobalSymbols
	/**
	 * A mixin used by control containers (cbn-form, cbn-dynamic-form etc.) to gain control over an input's model value.
	 * 
	 * @extends CbnForm.AbstractControl
	 */
	CbnForm.AbstractContainer = CbnForm.implement({
		
		publish: { // Published attributes:
			
			/**
			 * Dynamic form's data model to use for its inputs. 
			 * If not set, the parent container will manage the children's model.
			 * 
			 * @attribute model
			 * @type {Object}
			 * @default null
			 */
			model: CbnForm.NullObject
			
		}, 
		
		/**
		 * This property should be true only for the `cbn-form` element.
		 * 
		 * @type {Boolean}
		 * @default false
		 */
		isMasterContainer: false,
		
		/**
		 * A dynamic list that stores the input children of the container. 
		 * Accessible after the domReady callback.
		 * @type {CbnForm.AbstractControl[]}
		 * @default []
		 */
		childControls: null, 
		
		/**
		 * Like {@link #childControls}, but only stores the input elements whose values are bound to the container's 
		 * model.
		 * @type {CbnForm.AbstractInput[]}
		 * @default []
		 */
		childInputs: [], 
		
		
		/**
		 * Element instance created callback.
		 */
		_created: function(){
			this.childControls = [];
			this.childInputs = [];
		}, 
		
		/**
		 * Polymer element ready callback.
		 * 
		 * Binds to the form control attached / detached events, sets/unsets the parentForm property and the model 
		 * (value) bindings.
		 */
		_ready: function() {
			var container = this;
			var containerHasModel = (this.model && this.model != CbnForm.NullObject);
			
			this.addEventListener('cbn-form-control-attached', function (event) {
				var element = event.detail.element;
				container.childControls.push(element);
				
				if (container.isMasterContainer && element.parentForm != container) 
					element.parentForm = container;
				
				// bind to the input's value in a first-come, first-served manner
				if (containerHasModel && element.hasModelValue && !element.modelContainer) {
					container.bindValue(element);
					container.childInputs.push(element);
				}
			});
			
			this.addEventListener('cbn-form-control-detached', function (event) {
				var element = event.detail.element;
				if (container.isMasterContainer && element.parentForm == form) 
					element.parentForm = null;
				
				var idx = container.childControls.indexOf(element);
				if (idx >= 0) container.childControls.splice(idx, 1);
				
				if (element.hasModelValue && element.modelContainer == container) {
					container.unbindValue(element);
					
					idx = container.childInputs.indexOf(element);
					if (idx >= 0) container.childInputs.splice(idx, 1);
				}
			});
		}, 
		
		/**
		 * Model property changed. Used to detect changes to the model and re-bind the input values.
		 */
		modelChanged_: function() {
			for (var i=0; i<this.childInputs.length; i++) {
				var input = this.childInputs[i];
				this.bindValue(input);
			}
		}, 
		
		/**
		 * Requests the validation of all inputs and returns the boolean result.
		 * 
		 * @return {Boolean} The validation result (true if all child inputs passed validation).
		 */
		validate: function() {
			var i;
			var passed = true;
			
			for (i=0; i<this.childInputs.length; i++) {
				if (!this.childInputs[i].validate()) {
					passed = false;
					break;
				}
			}
			
			return passed;
		},
		
		/**
		 * Binds an observer to the given model to an input's value property.
		 * 
		 * @param {CbnForm.AbstractInput} input The target input to bind to.
		 */
		bindValue: function(input) {
			// HACK / workaround for a typo bug in the Node.bind() library 
			if (input['bindings_'] && input['bindings_']['value']) {
				input['bindings_']['value'].close();
				input['bindings_']['value'] = undefined;
			}
			input.bind('value', new PathObserver(this.model, input['name']));
			input.modelContainer = this;
		},
		
		/**
		 * Unbinds the observer for an input's value property.
		 * 
		 * @param {CbnForm.AbstractInput} input The target input to unbind.
		 * @param {Boolean}               [force=false] Set to true to force unbinding (even if the owner is not 'this').
		 */
		unbindValue: function(input, force) {
			if (force || input.modelContainer == this) {
				// the element will automatically be unbound by Polymer after being detached
				// so we only need to update the input's model container
				input.modelContainer = null;
			}
		}
		
	});
	
</script>
