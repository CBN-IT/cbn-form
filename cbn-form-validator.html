<!--
A library that implements a extensible validator for `cbn-form` input elements.
-->

<link rel="import" href="cbn-form-abstract.html">

<script>
	
	/**
	 * The object interface that needs to be implemented by the form validators. 
	 * 
	 * @typedef  {Object}   InputValidator
	 * @property {String}   name The name of the validator / the validation attribute used to invoke this validator.
	 * @property {String[]} types The validator types handled (see {@link CbnForm.AbstractInput#validatorType}). 
	 *                            There is a special type available: ['*'], which binds to all validator types.
	 * @property {String}   [message] The default validation message to display when the input is invalid.
	 * @property {Function} validate The validation function (that receives 4 parameters: the value to validate, 
	 *                               validator settings and, optionally, a reference to the input element and a stop 
	 *                               method to use to force stopping the validation process).
	 * 
	 * The settings property can be either:
	 * - a scalar value, if the validator only has a mandatory parameter (recommended for ease of use);
	 * - an object with validator settings; the following keys are reserved:
	 *    > validate: should store the reference value used by the validators;
	 *    > message: a validation message to display to the user if validation failed;
	 * 
	 * The validator should support both styles, the second style being required for custom validation message to work 
	 * (and the first is for convenience).
	 * You should also be able to disable a validator by giving it a false-y value to the settings parameter.
	 */
	
	/**
	 * The validation state object of a validatable input.
	 * 
	 * @typedef {Object} InputValidationState
	 * @property {Boolean} valid Whether the input is valid or not.
	 * @property {String}  message The validation message (if valid is false).
	 * 
	 * The validators may set any other property which may be used for debugging purposes, displaying a more 
	 * detailed error message to the user etc.
	 */
	
	//noinspection JSUnusedGlobalSymbols
	/**
	 * An extensible form input validator.
	 * 
	 * You can register new validators by using the {@link #register} method.
	 */
	CbnForm.Validator = {
		
		/**
		 * A map with the registered validators.
		 * The key is a special value composed of the validator name and its input value type.
		 * 
		 * @type {Object<String,InputValidator>}
		 */
		_validators: {},
		
		/**
		 * Internationalized validation messages.
		 * First key is the language ID, next one is the validator name.
		 * 
		 * @type {Object<String,Object<String,String>>}
		 */
		_messages: {},
		
		/**
		 * Specifies the default language for the validation messages.
		 * @type {String}
		 */
		language: '',
		
		/**
		 * Registers a new validator routine.
		 * 
		 * @param {InputValidator} obj The validator object to register.
		 */
		register: function(obj) {
			if (!obj.name || !obj.types) return false;
			if (!obj.types.length) return false;
			
			for (var i=0; i<obj.types.length; i++) {
				var key = obj.name + ">" + obj.types[i];
				this._validators[key] = obj;
			}
			
			return true;
		},
		
		/**
		 * Registers the validation messages.
		 * FIXME: use a proper i18n library?
		 * 
		 * @param {String} lng The language to register.
		 * @param {Object<String,String>} messages the translated validation messages.
		 */
		registerMessages: function (lng, messages) {
			this._messages[lng] = messages;
			if (!this.language) this.language = lng;
		},
		
		/**
		 * Validates an input element.
		 * 
		 * Check both native browser validation and custom validators and sets the appropriate validity state objects.
		 * 
		 * @param {CbnForm.ValidatableInput} input The input element to validate.
		 * @return {Boolean} True if all validations passed.
		 */
		validateInput: function(input) {
			if (!input.validation) return true;
			var i, v, settings; // iterators / auxiliary variables
			
			var valid = true;
			var failedValidator = '';
			var needToStop = false;
			var stop = function() { needToStop = true; };
			
			// reset validation state
			input.validationState = {};
			this._setInputValidity(input, '');
			
			// if the input supports native validation, check it first
			if (input.checkValidity && input.validity) {
				valid = input.checkValidity();
				if (!valid) {
					this._setInputValidity(input, this._getValidationMessage(input), true);
					return false;
				}
			}
			
			// built the list of validators to run
			var validatorsList = [];
			var validatorsSelected = {};
			if (input.validationOrder) {
				for (i=0; i<input.validationOrder.length; i++) {
					validatorsList.push(input.validationOrder[i]);
					validatorsSelected[input.validationOrder[i]] = true;
				}
			}
			if (input.validation) 
				for (v in input.validation) {
					if (!input.validation.hasOwnProperty(v)) continue;
					if (!validatorsSelected[v]) {
						validatorsList.push(v);
						validatorsSelected[v] = true;
					}
				}
			
			for (i=0; i<validatorsList.length; i++) {
				if (!input.validation.hasOwnProperty(validatorsList[i])) continue;
				
				var validatorObj = this._getValidatorObject(input.validationType, validatorsList[i]);
				if (!validatorObj) {
					continue;
				}
				
				settings = input.validation[validatorsList[i]];
				if (!validatorObj.validate(input.value, input.validation[validatorsList[i]], input, stop)) {
					valid = false;
					failedValidator = validatorsList[i];
					break;
				}
				if (needToStop) break;
			}
			
			if (!valid) {
				this._setInputValidity(input, this._getValidationMessage(input, failedValidator));
			} else {
				this._setInputValidity(input, '');
			}
			
			return valid;
		},
		
		// private methods
		
		/**
		 * Returns the requested InputValidator object.
		 * 
		 * @param {String} type The validator type.
		 * @param {String} validator Validator's name.
		 * @return {InputValidator} Validator's object / null if not registered.
		 */
		_getValidatorObject: function(type, validator) {
			var vk = null;
			if (validator) {
				vk = validator + ">" + type;
				if (!this._validators[vk]) {
					vk = validator + ">" + "*";
				}
			}
			if (!vk) return null;
			return (this._validators[vk] ? this._validators[vk] : null );
		},
		
		/**
		 * Returns the validation message to display when input validation fails.
		 * 
		 * @param {HTMLElement} input The target input element.
		 * @param {String} validator The failed validator (false for built-in validation).
		 * @param {Object} [settings] The validator settings used (optional, auto-set).
		 * @return {String} The validation message to set.
		 */
		_getValidationMessage: function(input, validator, settings) {
			if (validator && !settings) {
				settings = input.validation[validator];
			}
			if (validator && (typeof settings == 'object') && settings.message) 
				return settings.message;
			if (input.validationMessage) 
				return input.validationMessage;
			
			var validatorObj = null;
			if (validator) 
				validatorObj = this._getValidatorObject(input.validationType, validator);
			
			// i18n default message
			if (this._messages[this.language] && this._messages[this.language][validator]) 
				return this._messages[this.language][validator];
			if (this._messages[this.language] && this._messages[this.language]['_default'])
				return this._messages[this.language]['_default'];
			
			// fallback messages
			if (validatorObj && validatorObj.message) 
				return validatorObj.message;
			return 'Invalid value!';
		},
		
		/**
		 * Sets the input's validity state.
		 * 
		 * @param {CbnForm.ValidatableInput} input The input to set the validation state to.
		 * @param {String}      message The validation message (empty if the input validated successfully).
		 * @param {Boolean}     [native] True if the input was validated using native validation (and failed).
		 */
		_setInputValidity: function(input, message, native) {
			input._validationState.valid = (message == '');
			input._validationState.message = message;
			input.invalid = !input._validationState.valid;
			
			// if the input supports native HTML validation
			if (!native && input.setCustomValidity) {
				input.setCustomValidity(message);
			}
		}
		
	};
	
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Adds validation capabilities to a custom input element.
	 * 
	 * @extends HTMLElement
	 */
	CbnForm.ValidatableInput = {
		
		// Interface settings
		_extendProperties: [ 'dynamicAttributes' ],
		
		publish: { // Published attributes:
			
			/**
			 * The input's validation settings, a map where the key is the validator name and the value represents the 
			 * settings parameter to pass to the validator (which depends on the validator used).
			 * 
			 * @attribute validation
			 * @type {Object<String,*>}
			 */
			validation: null,
			
			/**
			 * An array with the order in which the validators should be executed.
			 * Any validators not specified here will be ran after every other validators entered here.
			 * 
			 * @attribute validationOrder
			 * @type {[String]}
			 */
			validationOrder: null,
			
			/**
			 * Describes the validator category to use, which is used by {@link CbnForm.Validator} to automatically choose a 
			 * validator to validate the input.
			 * 
			 * The predefined types are:
			 * - 'text': an input whose value is entered as string and validated as such; includes most of the definable 
			 *   input types (including numeric and date inputs);
			 * - 'file': for file inputs, where the input value is a file metadata object (see {@link CbnForm.AbstractFileInput});
			 * - 'multiple': for validating an array of values.
			 * 
			 * @attribute validationType
			 * @type {String}
			 */
			validationType: 'text',
			
			/**
			 * The validation message to display to the user if the validation failed.
			 * 
			 * @attribute validationMessage
			 * @type {String}
			 */
			validationMessage: '',
			
			/**
			 * This attribute will be automatically set when the validation fails.
			 * Can be used as CSS selector (reflection is enabled).
			 * 
			 * @attribute invalid
			 * @type {Boolean}
			 */
			invalid: {
				value: false,
				reflect: true
			}
			
		},
		
		// Events
		
		/**
		 * Fired after the input is validated.
		 * 
		 * @event cbn-form-validate
		 */
		
		// DOM Properties: 
		
		/**
		 * Stores the validation state of the input element.
		 * 
		 * @type {InputValidationState}
		 */
		_validationState: null,
		
		/**
		 * Validation dynamically-configurable attributes.
		 */
		dynamicAttributes: {
			"validation" : { type: 'property' }, 
			"validationOrder" : { type: 'property' }, 
			"validationType" : { type: 'attribute' },
			"validationMessage" : { type: 'attribute' }
		},
		
		/**
		 * Returns the validation state of the input.
		 * 
		 * @property validationState
		 * @type {InputValidationState}
		 */
		get validationState() {
			return this._validationState;
		},
		
		
		// Methods
		
		/**
		 * Element instance created callback.
		 */
		_created: function () {
			if (!this.validation) this.validation = {};
			if (!this.validationOrder) {
				this.validationOrder = [ 'required' ];
			}
			this._validationState = {
				valid: true, message: ''
			};
		},
		
		
		/**
		 * Requests validation of the input (called by the form element before submit).
		 * 
		 * @return {Boolean} True if the input validates, false otherwise.
		 */
		validate: function () {
			var result = CbnForm.Validator.validateInput(this);
			this.fire('cbn-form-validate', { result: result });
			return result;
		}
		
	};
	
	/**
	 * Built-in validators.
	 * 
	 * All validators support both styles for its settings parameter. 
	 * If you want to specify it as Object, use the 'validate' property to specify the parameter to validate with.
	 */
	(function(Validator) {
		
		function normalizeSettings(settings) {
			if (typeof settings == 'object')
				return settings;
			return {
				validate: settings,
				message: null
			};
		}
		
		// String-based validators
		
		/**
		 * Validates whether the input value is not empty (or false-y).
		 * 
		 * @param {Boolean} settings
		 */
		Validator.register({
			name: 'required',
			types: ['*'],
			message: 'This field is mandatory!',
			validate: function(value, settings, input, stop) {
				settings = normalizeSettings(settings);
				var required = settings.validate;
				if (required) // if required=true, validate the input
					return !!value;
				
				if (!required && !value) // stop the rest of the validation if the value is not specified
					stop();
				return true;
			}
		});
		
		/**
		 * Implements common pattern-based validators.
		 */
		var PatternValidator = {
			_patterns: {
				email: { validate: '^((([a-z]|\\d|[!#\\$%&\'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+' +
					'(\\.([a-z]|\\d|[!#\\$%&\'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|' +
					'((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|' +
					'[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|' +
					'[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@' +
					'((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])' +
					'([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+' +
					'(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])' +
					'([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?$', 
					modifiers: 'i' }
			},
			validate: function(value, settings/*, input, stop */) {
				// 'this' is the registered validator
				settings = normalizeSettings(settings);
				var pattern = settings.validate;
				var modifiers = (settings.modifiers ? settings.modifiers : '');
				if (!pattern) return true; // validator is disabled
				
				try {
					pattern = new RegExp(pattern, modifiers);
					if (!pattern) { //noinspection ExceptionCaughtLocallyJS
						throw settings.validate+'';
					}
					
					return pattern.test(value+'');
					
				} catch (e) {
					console.error('CbnFrom.Validator(\'pattern\'): invalid pattern!', e);
					return false;
				}
			},
			
			validateWithPattern: function(value, settings) {
				// 'this' is the registered validator
				settings = normalizeSettings(settings);
				if (!settings.validate) 
					return true;
				return PatternValidator.validate.call(this, value, PatternValidator._patterns[this.name]);
			}
		};
		
		/**
		 * Validates whether the value matches the specified pattern.
		 */
		Validator.register({
			name: 'pattern',
			types: ['text'],
			message: 'Invalid value!',
			validate: PatternValidator.validate
		});
		
		/**
		 * Validates whether the value is a (hopefully) valid email.
		 */
		Validator.register({
			name: 'email',
			types: ['text'],
			message: 'Invalid email!',
			validate: PatternValidator.validateWithPattern
		});
		
		/**
		 * Validates whether the value has a length greater or equal than a reference value.
		 */
		Validator.register({
			name: 'minlength',
			types: ['text'],
			message: 'The value is too short!',
			validate: function(value, settings/*, input, stop */) {
				settings = normalizeSettings(settings);
				value = value+'';
				if (!settings.validate)
					return true;
				
				return (value.length >= settings.validate);
			}
		});
		
		/**
		 * Validates whether the value has a length lesser or equal than a reference value.
		 */
		Validator.register({
			name: 'maxlength',
			types: ['text'],
			message: 'The text is too large!',
			validate: function(value, settings/*, input, stop */) {
				settings = normalizeSettings(settings);
				value = value+'';
				if (!settings.validate)
					return true;
				
				return (value.length <= settings.validate);
			}
		});
		
		
		// Number validators
		
		/**
		 * Implements common routines to use by all number validators.
		 */
		var NumberValidator = {
			isInteger: function(value) {
				return !!/^[+-]?[0-9]+$/.test(value+'');
			},
			
			isFloat: function(value) {
				return !!/^[+-]?[0-9]+(\.[0-9]*)?$/.test(value+'');
			},
			
			validateNumber: function(value, settings) {
				// 'this' is the actual validator instance
				settings = normalizeSettings(settings);
				if (!settings.validate)
					return true;
				
				value = 1*value;
				if (isNaN(value)) 
					return false;
				
				switch (this.name) {
					case 'min': 
						return (value >= settings.validate);
					case 'max': 
						return (value <= settings.validate);
				}
			}
		};
		
		/**
		 * Validates whether the value is a valid number.
		 * 
		 * Additional settings arguments:
		 * - 'type': the type of numeric values allowed ('integer' - default, 'float' available);
		 */
		Validator.register({
			name: 'number',
			types: ['text'],
			message: 'The value needs to be a number!',
			validate: function(value, settings/*, input, stop */) {
				settings = normalizeSettings(settings);
				if (!settings.validate)
					return true;
				
				if (settings.type == 'double') {
					return NumberValidator.isFloat(value);
					
				} else {
					return NumberValidator.isInteger(value);
				}
			}
		});
		
		/**
		 * Validates whether the input's value (which must be a number) is greater or equal than a reference value.
		 */
		Validator.register({
			name: 'min',
			types: ['text'],
			message: 'The number is too small!',
			validate: NumberValidator.validateNumber
		});
		
		/**
		 * Validates whether the input's value (which must be a number) is greater or equal than a reference value.
		 */
		Validator.register({
			name: 'max',
			types: ['text'],
			message: 'The number is too large!',
			validate: NumberValidator.validateNumber
		});
		
		
		// 2. Multiple text validators
		
		/**
		 * Validates whether the input array is not empty.
		 * 
		 * @param {Boolean} settings
		 */
		Validator.register({
			name: 'required',
			types: ['multiple'],
			message: 'This field is mandatory!',
			validate: function(value, settings, input, stop) {
				settings = normalizeSettings(settings);
				var required = settings.validate;
				if (!Array.isArray(value))
					return false;
				if (required)  // if required=true, validate the input
					return value.length > 0;
				
				if (!required && !value.length) // stop the rest of the validation if the value is not specified
					stop();
				return true;
			}
		});
		
		/**
		 * Validates whether the input array has a length greater or equal than the reference value.
		 */
		Validator.register({
			name: 'minlength',
			types: ['multiple'],
			message: 'Too few items selected!',
			validate: function(value, settings/*, input, stop */) {
				settings = normalizeSettings(settings);
				if (!settings.validate)
					return true;
				if (!Array.isArray(value))
					return false;
				
				return (value.length >= settings.validate);
			}
		});
		
		/**
		 * Validates whether the value has a length lesser or equal than the reference value.
		 */
		Validator.register({
			name: 'maxlength',
			types: ['multiple'],
			message: 'Too many items selected!',
			validate: function(value, settings/*, input, stop */) {
				settings = normalizeSettings(settings);
				if (!settings.validate)
					return true;
				if (!Array.isArray(value))
					return false;
				
				return (value.length <= settings.validate);
			}
		});
		
		
	})(CbnForm.Validator);
	
</script>
