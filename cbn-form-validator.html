<!--
A library that implements a extensible validator for `cbn-form` input elements.
-->

<link rel="import" href="cbn-form-abstract.html">

<script>
	
	/**
	 * The object interface that needs to be implemented by the form validators. 
	 * 
	 * @typedef  {Object}   InputValidator
	 * @property {String}   name The name of the validator / the validation attribute used to invoke this validator.
	 * @property {String[]} types The validator types handled (see {@link CbnForm.AbstractInput#validatorType}). 
	 *                            There is a special type available: ['*'], which binds to all validator types.
	 * @property {Function} validate The validation function (that receives 4 parameters: the value to validate, 
	 *                               validator settings and, optionally, a reference to the input element and a stop 
	 *                               method to use to force stopping the validation process).
	 * 
	 * The settings property can be either:
	 * - a scalar value, if the validator only has a mandatory parameter (recommended for ease of use);
	 * - an object with validator settings; the following keys are reserved:
	 *    > validate: should store the reference value used by the validators;
	 *    > message: a validation message to display to the user if validation failed;
	 * 
	 * The validator should support both styles, the second style being required for custom validation message to work 
	 * (and the first is for convenience).
	 * You should also be able to disable a validator by giving it a false-y value to the settings parameter.
	 */
	
	/**
	 * The validation state object of a validatable input.
	 * 
	 * @typedef {Object} InputValidationState
	 * @property {Boolean} valid Whether the input is valid or not.
	 * @property {String}  message The validation message (if valid is false).
	 * 
	 * The validators may set any other property which may be used for debugging purposes, displaying a more 
	 * detailed error message to the user etc.
	 */
	
	/**
	 * An extensible form input validator.
	 * 
	 * You can register new validators by using the {@link #register} method.
	 */
	CbnForm.Validator = {
		
		/**
		 * A map with the registered validators.
		 * The key is a special value composed of the validator name and its input value type.
		 * 
		 * @type {Object<String,InputValidator>}
		 */
		_validators: {},
		
		
		/**
		 * Registers a new validator routine.
		 * 
		 * @param {InputValidator} obj The validator object to register.
		 */
		register: function(obj) {
			if (!obj.name || !obj.types) return false;
			if (!obj.types.length) return false;
			
			for (var i=0; i<obj.types.length; i++) {
				var key = obj.name + ">" + obj.types[i];
				this._validators[key] = obj;
			}
			
			return true;
		},
		
		/**
		 * Validates an input element.
		 * 
		 * Check both native browser validation and custom validators and sets the appropriate validity state objects.
		 * 
		 * @param {CbnForm.ValidatableInput} input The input element to validate.
		 * @return {Boolean} True if all validations passed.
		 */
		validateInput: function(input) {
			if (!input.validation) return true;
			var i, v, vk, settings; // iterators / auxiliary variables
			
			var valid = true;
			var message = '';
			var needToStop = false;
			var stop = function() { run = false; };
			
			// reset validation state
			input.validationState = {};
			this._setInputValidity(input, '');
			
			// if the input supports native validation, check it first
			if (input.checkValidity && input.validity) {
				valid = input.checkValidity();
				if (!valid) {
					message = input.validationMessage;
					if (!message) 
						message = "Invalid value!";
					this._setInputValidity(input, message, true);
					return false;
				}
			}
			
			// built the list of validators to run
			var validatorsList = [];
			var validatorsSelected = {};
			if (input.validationOrder) {
				for (i=0; i<input.validationOrder.length; i++) {
					validatorsList.push(input.validationOrder[i]);
					validatorsSelected[input.validationOrder[i]] = true;
				}
			}
			if (input.validation) 
				for (v in input.validation) {
					if (!input.validation.hasOwnProperty(v)) continue;
					if (!validatorsSelected[v]) {
						validatorsList.push(v);
						validatorsSelected[v] = true;
					}
				}
			
			for (i=0; i<validatorsList.length; i++) {
				if (!input.validation.hasOwnProperty(validatorsList[i])) continue;
				
				vk = validatorsList[i] + ">" + input.validationType;
				if (!this._validators[vk]) {
					// try again with the wildcard type
					vk = validatorsList[i] + ">" + "*";
					if (!this._validators[vk]) {
						console.error('CbnFrom.Validator#validateInput: validator \'' + validatorsList[i] + '\' is not registered!');
						valid = false; break;
					}
				}
				
				settings = input.validation[validatorsList[i]];
				if (!this._validators[vk].validate(input.value, input.validation[validatorsList[i]], input, stop)) {
					valid = false;
					
					if (typeof settings == 'object' && settings.message) {
						message = settings.message;
					}
					break;
				}
				if (needToStop) break;
			}
			
			if (!valid && !message) {
				message = input.validationMessage;
				if (!message) {
					message = 'Invalid value!';
				}
			}
			this._setInputValidity(input, message);
			
			return valid;
		},
		
		/**
		 * Sets the input's validity state.
		 * 
		 * @param {HTMLElement} input The input to set the validation state to.
		 * @param {String}      message The validation message (empty if the input validated successfully).
		 * @param {Boolean}     native True if the input was validated using native validation (and failed).
		 */
		_setInputValidity: function(input, message, native) {
			input._validationState.valid = (message == '');
			input._validationState.message = message;
			input.invalid = !input._validationState.valid;
			
			// if the input supports native HTML validation
			if (!native && input.setCustomValidity) {
				input.setCustomValidity(message);
			}
		}
		
	};
	
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Adds validation capabilities to a custom input element.
	 */
	CbnForm.ValidatableInput = {
		
		// Interface settings
		_extendProperties: [ 'dynamicAttributes' ],
		
		publish: { // Published attributes:
			
			/**
			 * The input's validation settings, a map where the key is the validator name and the value represents the 
			 * settings parameter to pass to the validator (which depends on the validator used).
			 * 
			 * @attribute validation
			 * @type {Object<String,*>}
			 */
			validation: null,
			
			/**
			 * An array with the order in which the validators should be executed.
			 * Any validators not specified here will be ran after every other validators entered here.
			 * 
			 * @attribute validationOrder
			 * @type {[String]}
			 */
			validationOrder: null,
			
			/**
			 * Describes the validator category to use, which is used by {@link CbnForm.Validator} to automatically choose a 
			 * validator to validate the input.
			 * 
			 * The predefined types are:
			 * - 'text': an input whose value is entered as string and validated as such; includes most of the definable 
			 *   input types (including numeric and date inputs);
			 * - 'file': for file inputs, where the input value is a file metadata object (see {@link CbnForm.AbstractFileInput});
			 * - 'multiple': for validating an array of values.
			 * 
			 * @attribute validationType
			 * @type {String}
			 */
			validationType: 'text',
			
			/**
			 * The validation message to display to the user if the validation failed.
			 * 
			 * @attribute validationMessage
			 * @type {String}
			 */
			validationMessage: '',
			
			/**
			 * This attribute will be automatically set when the validation fails.
			 * Can be used as CSS selector (reflection is enabled).
			 */
			invalid: {
				value: false,
				reflect: true
			}
			
		},
		
		// DOM Properties: 
		
		/**
		 * Stores the validation state of the input element.
		 * 
		 * @type {InputValidationState}
		 */
		_validationState: null,
		
		/**
		 * Validation dynamically-configurable attributes.
		 */
		dynamicAttributes: {
			"validation" : { type: 'property' }, 
			"validationOrder" : { type: 'property' }, 
			"validationType" : { type: 'attribute' },
			"validationMessage" : { type: 'attribute' }
		},
		
		/**
		 * Returns the validation state of the input.
		 * 
		 * @property validationState
		 * @type {InputValidationState}
		 */
		get validationState() {
			return this._validationState;
		},
		
		
		// Methods
		
		/**
		 * Element instance created callback.
		 */
		_created: function () {
			if (!this.validation) this.validation = {};
			if (!this.validationOrder) {
				this.validationOrder = [ 'required' ];
			}
			this._validationState = {
				valid: true, message: ''
			};
		},
		
		
		/**
		 * Requests validation of the input (called by the form element before submit).
		 * 
		 * @return {Boolean} True if the input validates, false otherwise.
		 */
		validate: function () {
			return CbnForm.Validator.validateInput(this);
		}
		
	};
	
	/**
	 * Built-in validators.
	 * 
	 * All validators support both styles for its settings parameter. 
	 * If you want to specify it as Object, use the 'validate' property to specify the parameter to validate with.
	 */
	(function(Validator) {
		
		function normalizeSettings(settings) {
			if (typeof settings == 'object')
				return settings;
			return {
				validate: settings,
				message: null
			};
		}
		
		// String-based validators
		
		/**
		 * Validates whether the input value is not empty (or false-y).
		 * 
		 * @param {Boolean} settings
		 */
		Validator.register({
			name: 'required',
			types: ['*'],
			validate: function(value, settings, input, stop) {
				settings = normalizeSettings(settings);
				var required = settings.validate;
				if (required) // if required=true, validate the input
					return !!value;
				
				if (!required && !value) // stop the rest of the validation if the value is not specified
					stop();
				return true;
			}
		});
		
		/**
		 * Implements common pattern-based validators.
		 */
		var PatternValidator = {
			_patterns: {
				email: { validate: '^[^@]+@[^@]+\.[^@]+$' }
			},
			
			validate: function(value, settings/*, input, stop */) {
				// 'this' is the registered validator
				settings = normalizeSettings(settings);
				var pattern = settings.validate;
				var modifiers = (settings.modifiers ? settings.modifiers : '');
				if (!pattern) return true; // validator is disabled
				
				try {
					pattern = new RegExp(pattern, modifiers);
					if (!pattern) return false;
					
					return pattern.test(value+'');
					
				} catch (e) {
					console.error('CbnFrom.Validator(\'pattern\'): invalid pattern!', e);
					return false;
				}
			},
			
			validateWithPattern: function(value, settings) {
				// 'this' is the registered validator
				settings = normalizeSettings(settings);
				if (!settings.validate) 
					return true;
				return PatternValidator.validate.call(this, value, {
					validate: PatternValidator._patterns[this.type]
				});
			}
		};
		
		/**
		 * Validates whether the value matches the specified pattern.
		 */
		Validator.register({
			name: 'pattern',
			types: ['text'],
			validate: PatternValidator.validate
		});
		
		/**
		 * Validates whether the value is a (hopefully) valid email.
		 */
		Validator.register({
			name: 'email',
			types: ['text'],
			validate: PatternValidator.validateWithPattern
		});
		
		/**
		 * Validates whether the value has a length greater or equal than a reference value.
		 */
		Validator.register({
			name: 'minlength',
			types: ['text'],
			validate: function(value, settings/*, input, stop */) {
				settings = normalizeSettings(settings);
				value = value+'';
				if (!settings.validate)
					return true;
				
				return (value.length >= settings.validate);
			}
		});
		
		/**
		 * Validates whether the value has a length lesser or equal than a reference value.
		 */
		Validator.register({
			name: 'maxlength',
			types: ['text'],
			validate: function(value, settings/*, input, stop */) {
				settings = normalizeSettings(settings);
				value = value+'';
				if (!settings.validate)
					return true;
				
				return (value.length <= settings.validate);
			}
		});
		
		
		// Number validators
		
		/**
		 * Implements common routines to use by all number validators.
		 */
		var NumberValidator = {
			isInteger: function(value) {
				return !!/^[+-]?[0-9]+$/.match(value+'');
			},
			
			isFloat: function(value) {
				return !!/^[+-]?[0-9]+(\.[0-9]*)?$/.match(value+'');
			},
			
			validateNumber: function(value, settings) {
				// 'this' is the actual validator instance
				settings = normalizeSettings(settings);
				if (!settings.validate)
					return true;
				
				value = 1*value;
				if (isNaN(value)) 
					return false;
				
				switch (this.name) {
					case 'min': 
						return (value >= settings.validate);
					case 'max': 
						return (value <= settings.validate);
				}
			}
		};
		
		/**
		 * Validates whether the value is a valid number.
		 * 
		 * Additional settings arguments:
		 * - 'type': the type of numeric values allowed ('integer' - default, 'float' available);
		 */
		Validator.register({
			name: 'number',
			types: ['text'],
			validate: function(value, settings/*, input, stop */) {
				settings = normalizeSettings(settings);
				if (!settings.validate)
					return true;
				
				if (settings.type == 'float') {
					return NumberValidator.isFloat(value);
					
				} else {
					return NumberValidator.isInteger(value);
				}
			}
		});
		
		/**
		 * Validates whether the input's value (which must be a number) is greater or equal than a reference value.
		 */
		Validator.register({
			name: 'min',
			types: ['text'],
			validate: NumberValidator.validateNumber
		});
		
		/**
		 * Validates whether the input's value (which must be a number) is greater or equal than a reference value.
		 */
		Validator.register({
			name: 'max',
			types: ['text'],
			validate: NumberValidator.validateNumber
		});
		
		
		// 2. Multiple text validators
		
		/**
		 * Validates whether the input array is not empty.
		 * 
		 * @param {Boolean} settings
		 */
		Validator.register({
			name: 'required',
			types: ['multiple'],
			validate: function(value, settings, input, stop) {
				settings = normalizeSettings(settings);
				var required = settings.validate;
				if (!Array.isArray(value))
					return false;
				if (required)  // if required=true, validate the input
					return value.length > 0;
				
				if (!required && !value.length) // stop the rest of the validation if the value is not specified
					stop();
				return true;
			}
		});
		
		/**
		 * Validates whether the input array has a length greater or equal than the reference value.
		 */
		Validator.register({
			name: 'minlength',
			types: ['multiple'],
			validate: function(value, settings/*, input, stop */) {
				settings = normalizeSettings(settings);
				if (!settings.validate)
					return true;
				if (!Array.isArray(value))
					return false;
				
				return (value.length >= settings.validate);
			}
		});
		
		/**
		 * Validates whether the value has a length lesser or equal than the reference value.
		 */
		Validator.register({
			name: 'maxlength',
			types: ['multiple'],
			validate: function(value, settings/*, input, stop */) {
				settings = normalizeSettings(settings);
				if (!settings.validate)
					return true;
				if (!Array.isArray(value))
					return false;
				
				return (value.length <= settings.validate);
			}
		});
		
		
	})(CbnForm.Validator);
	
</script>
